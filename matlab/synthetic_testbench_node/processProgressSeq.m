function [dataset] = processProgressSeq(progress_seq, label)
% Process raw data structure generated by SyntheticTestbenchNode into named dataset array

dataset.label = label;

% Re-organize correctly-decoded entries into a dataset array matrix,
% where each phase is mapped to a separate row (observation).
% Also record raw entries that had more than a single tag detection,
% as well as raw entries with no tag detections.
dataset.tag_type_id = progress_seq{1}.tag_type_id;
dataset.tag_num_slices = progress_seq{1}.tag_num_slices;
dataset.tag_num_freqs = progress_seq{1}.tag_num_freqs;
dataset.multi_detection_raw_IDs = [];
dataset.zero_detection_raw_IDs = [];
obs = [];
obscount = 0;
radians = pi/180.0;
num_progress_seq = length(progress_seq);

for seq_id = 1:num_progress_seq,
  if mod(seq_id, 100) == 0,
    fprintf('Processing %d/%d entries...\n', seq_id, num_progress_seq);
  end
  
  t = progress_seq{seq_id};
  if ~isfield(t, 'ftag2_num_tags_detected'),
    warning('processTargetSeq:IncompleteData', 'Raw target_seq entry %d missing FTag2 decoded results', seq_id);
  else
    if t.ftag2_num_tags_detected == 0,
      dataset.zero_detection_raw_IDs = [dataset.zero_detection_raw_IDs; seq_id];
    else
      if t.ftag2_num_tags_detected > 1,
        dataset.multi_detection_raw_IDs = [dataset.multi_detection_raw_IDs; seq_id, t.ftag2_num_tags_detected];
      end
      
      % Collect data shared by all payload phases
      % NOTE: all rotation angles (rx/ry/rz) are specified with respect to
      % moving tag in static camera frame; thus each tag's pitch/roll/yaw
      % angles must be computed by inverting the static and moving frames
      [tag_pitch_rad, tag_yaw_rad, tag_roll_rad] = tf_euler_inverse( ...
        t.tag_rx_deg*radians, t.tag_ry_deg*radians, t.tag_rz_deg*radians);
      [ftag2_pitch_rad, ftag2_yaw_rad, ftag2_roll_rad] = tf_euler_inverse( ...
        t.ftag2_rx_deg*radians, t.ftag2_ry_deg*radians, t.ftag2_rz_deg*radians);
      ftag2_vec = [ ...
        seq_id, ...
        t.ftag2_frame_id, ...
        t.tag_width_m, ...
        t.tag_tx_m, ...
        t.tag_ty_m, ...
        t.tag_tz_m, ...
        t.tag_rx_deg, ...
        t.tag_ry_deg, ...
        t.tag_rz_deg, ...
        tag_pitch_rad/radians, ...
        tag_yaw_rad/radians, ...
        tag_roll_rad/radians, ...
        t.ftag2_width_px, ...
        t.ftag2_tx_m, ...
        t.ftag2_ty_m, ...
        t.ftag2_tz_m, ...
        t.ftag2_rx_deg, ...
        t.ftag2_ry_deg, ...
        t.ftag2_rz_deg, ...
        ftag2_pitch_rad/radians, ...
        ftag2_yaw_rad/radians, ...
        ftag2_roll_rad/radians, ...
        t.ftag2_tag_img_rot, ...
        ];
      
      % Create individual row observations per payload phase
      phase_idx = 0;
      for slice_j = 1:t.tag_num_slices,
        for freq_k = 1:t.tag_num_freqs,
          obscount = obscount + 1;
          phase_idx = phase_idx + 1;
          obs(obscount, :) = [ ...
            ftag2_vec, ...
            slice_j, ...
            freq_k, ...
            t.tag_phases_vec(phase_idx), ...
            t.ftag2_phases_vec(phase_idx), ...
            t.ftag2_mags_vec(phase_idx), ...
            ]; %#ok<AGROW>
        end
      end
    end
  end
end

% Convert into dataset array
dataset.ds = mat2dataset(obs, 'VarNames', {...
  'id_seq', ...
  'id_frame', ...
  'tag_width_m', ...
  'tag_tx_m', ...
  'tag_ty_m', ...
  'tag_tz_m', ...
  'tag_rx_deg', ...
  'tag_ry_deg', ...
  'tag_rz_deg', ...
  'tag_pitch_deg', ...
  'tag_yaw_deg', ...
  'tag_roll_deg', ...
  'ftag2_width_px', ...
  'ftag2_tx_m', ...
  'ftag2_ty_m', ...
  'ftag2_tz_m', ...
  'ftag2_rx_deg', ...
  'ftag2_ry_deg', ...
  'ftag2_rz_deg', ...
  'ftag2_pitch_deg', ...
  'ftag2_yaw_deg', ...
  'ftag2_roll_deg', ...
  'ftag2_tag_img_rot', ...
  'tag_slice', ...
  'tag_freq', ...
  'tag_phase_deg', ...
  'ftag2_phase_deg', ...
  'ftag2_mag', ...
  });

end
