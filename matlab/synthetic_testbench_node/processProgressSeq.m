function [dataset] = processProgressSeq(progress_seq, label, image_width_px, image_height_px)
% Process raw data structure generated by SyntheticTestbenchNode into named dataset array

if nargin < 3,
  image_width_px = 800;
end
if nargin < 4,
  image_height_px = 600;
end

dataset.label = label;

% Re-organize correctly-decoded entries into a dataset array matrix,
% where each phase is mapped to a separate row (observation).
% Also record raw entries that had more than a single tag detection,
% as well as raw entries with no tag detections.
dataset.tag_type_id = progress_seq{1}.tag_type_id;
dataset.tag_num_slices = progress_seq{1}.tag_num_slices;
dataset.tag_num_freqs = progress_seq{1}.tag_num_freqs;

radians = pi/180.0;
num_progress_seq = length(progress_seq);

% Count number of expected seq and obs entries
exp_seqcount = 0;
exp_obscount = 0;
for seq_id = 1:num_progress_seq,
  t = progress_seq{seq_id};
  if ~isfield(t, 'ftag2_num_tags_detected'),
    warning('processTargetSeq:IncompleteData', 'Raw target_seq entry %d missing FTag2 decoded results', seq_id);
  else
    exp_seqcount = exp_seqcount + 1;
    if t.ftag2_num_tags_detected > 0,
      exp_obscount = exp_obscount + length(t.tag_phases_vec);
    end
  end
end

seq = zeros(exp_seqcount, 52);
seqcount = 0;

obs = zeros(exp_obscount, 59);
obscount = 0;

for seq_id = 1:num_progress_seq,
  if mod(seq_id, 100) == 0,
    fprintf('Processing %d/%d entries...\n', seq_id, num_progress_seq);
  end
  
  t = progress_seq{seq_id};
  if ~isfield(t, 'ftag2_num_tags_detected'),
    continue;
  else
    % Collect data shared by all detected tags in image
    [tag_pitch_rad, tag_yaw_rad, tag_roll_rad] = tf_euler_inverse( ...
      t.tag_rx_deg*radians, t.tag_ry_deg*radians, t.tag_rz_deg*radians);
    tag_pitch_deg = tag_pitch_rad/radians;
    tag_yaw_deg = tag_yaw_rad/radians;
    tag_roll_deg = tag_roll_rad/radians;
    tag_oop_deg = tf_angle_between_euler_poses(tag_pitch_deg, tag_yaw_deg, tag_roll_deg, 0, 0, 0, 'xyz', 'xyz', [0;0;1]);
    seq_vec = [ ...
      seq_id, ...
      t.tag_width_m, ...
      t.tag_tx_m, ...
      t.tag_ty_m, ...
      t.tag_tz_m, ...
      t.tag_rx_deg, ...
      t.tag_ry_deg, ...
      t.tag_rz_deg, ...
      tag_pitch_deg, ...
      tag_yaw_deg, ...
      tag_roll_deg, ...
      tag_oop_deg, ...
      t.ftag2_num_tags_detected];

    ftag2_vec = nan(1, 39);
    if t.ftag2_num_tags_detected > 0,
      % Collect data shared by all payload phases
      % NOTE: all rotation angles (rx/ry/rz) are specified with respect to
      % moving tag in static camera frame; thus each tag's pitch/roll/yaw
      % angles must be computed by inverting the static and moving frames
      [ftag2_pitch_rad, ftag2_yaw_rad, ftag2_roll_rad] = tf_euler_inverse( ...
        t.ftag2_rx_deg*radians, t.ftag2_ry_deg*radians, t.ftag2_rz_deg*radians);
      ftag2_pitch_deg = ftag2_pitch_rad/radians;
      ftag2_yaw_deg = ftag2_yaw_rad/radians;
      ftag2_roll_deg = ftag2_roll_rad/radians;
      ftag2_oop_deg = tf_angle_between_euler_poses(ftag2_pitch_deg, ftag2_yaw_deg, ftag2_roll_deg, 0, 0, 0, 'xyz', 'xyz', [0;0;1]);
      
      quad_border_mindist_px = min(...
        min(t.ftag2_tag_corners(1:2:7)), ...
        min(image_width_px-1-t.ftag2_tag_corners(1:2:7)), ...
        min(t.ftag2_tag_corners(2:2:8)), ...
        min(image_height_px-1-t.ftag2_tag_corners(2:2:8)));
      %corner_vec12 = [t.ftag2_tag_corners(3)-t.ftag2_tag_corners(1), t.ftag2_tag_corners(4)-t.ftag2_tag_corners(2)];
      %corner_vec23 = [t.ftag2_tag_corners(5)-t.ftag2_tag_corners(3), t.ftag2_tag_corners(6)-t.ftag2_tag_corners(4)];
      %corner_vec34 = [t.ftag2_tag_corners(7)-t.ftag2_tag_corners(5), t.ftag2_tag_corners(8)-t.ftag2_tag_corners(6)];
      %corner_vec41 = [t.ftag2_tag_corners(1)-t.ftag2_tag_corners(7), t.ftag2_tag_corners(2)-t.ftag2_tag_corners(8)];
      corner_vec13 = [t.ftag2_tag_corners(5)-t.ftag2_tag_corners(1), t.ftag2_tag_corners(6)-t.ftag2_tag_corners(2)];
      corner_vec24 = [t.ftag2_tag_corners(7)-t.ftag2_tag_corners(3), t.ftag2_tag_corners(8)-t.ftag2_tag_corners(4)];
      %corner_d12 = sqrt(corner_vec12*corner_vec12');
      %corner_d23 = sqrt(corner_vec23*corner_vec23');
      %corner_d34 = sqrt(corner_vec34*corner_vec34');
      %corner_d41 = sqrt(corner_vec41*corner_vec41');
      corner_d13 = sqrt(corner_vec13*corner_vec13');
      corner_d24 = sqrt(corner_vec24*corner_vec24');
      corner_cross_deg = acosd(corner_vec13*corner_vec24'/corner_d13/corner_d24);
      quad_area_px2 = sind(corner_cross_deg)*corner_d13*corner_d24/2;
      if corner_d13 < corner_d24,
        quad_diag1_px = corner_d13;
        quad_diag2_px = corner_d24;
      else
        quad_diag1_px = corner_d24;
        quad_diag2_px = corner_d13;
      end
      diff_txy_m = sqrt((t.ftag2_tx_m - t.tag_tx_m)^2 + ...
        (t.ftag2_ty_m - t.tag_ty_m)^2);
      diff_txyz_m = sqrt((t.ftag2_tx_m - t.tag_tx_m)^2 + ...
        (t.ftag2_ty_m - t.tag_ty_m)^2 + (t.ftag2_tz_m - t.tag_tz_m)^2);
      diff_rxy_deg = tf_angle_between_euler_poses( ...
        t.tag_rx_deg, ...
        t.tag_ry_deg, ...
        t.tag_rz_deg, ...
        t.ftag2_rx_deg, ...
        t.ftag2_ry_deg, ...
        t.ftag2_rz_deg, 'xyz', 'xyz', [0;0;1]);
      diff_payload_str_n = ...
        sum(strrep(t.ftag2_payload_str, '_', '') ~= strrep(t.tag_source(end-20:end-4), '_', ''));
      
      ftag2_vec = [ ...
        t.ftag2_frame_id, ...
        t.ftag2_width_px, ...
        t.ftag2_tx_m, ...
        t.ftag2_ty_m, ...
        t.ftag2_tz_m, ...
        t.ftag2_rx_deg, ...
        t.ftag2_ry_deg, ...
        t.ftag2_rz_deg, ...
        ftag2_pitch_deg, ...
        ftag2_yaw_deg, ...
        ftag2_roll_deg, ...
        ftag2_oop_deg, ...
        t.ftag2_tag_img_rot, ...
        t.ftag2_tx_m - t.tag_tx_m, ...
        t.ftag2_ty_m - t.tag_ty_m, ...
        t.ftag2_tz_m - t.tag_tz_m, ...
        diff_txy_m, ...
        diff_txyz_m, ...
        angularDiff(t.tag_rx_deg, t.ftag2_rx_deg), ...
        angularDiff(t.tag_ry_deg, t.ftag2_ry_deg), ...
        angularDiff(t.tag_rz_deg, t.ftag2_rz_deg), ...
        angularDiff(tag_pitch_deg, ftag2_pitch_deg), ...
        angularDiff(tag_yaw_deg, ftag2_yaw_deg), ...
        angularDiff(tag_roll_deg, ftag2_roll_deg), ...
        angularDiff(tag_oop_deg, ftag2_oop_deg), ...
        diff_rxy_deg, ...
        t.ftag2_tag_corners, ...
        quad_diag1_px, ...
        quad_diag2_px, ...
        quad_area_px2, ...
        quad_border_mindist_px, ...
        diff_payload_str_n, ...
        ];
      
      % Create individual row observations per payload phase
      phase_idx = 0;
      for slice_j = 1:t.tag_num_slices,
        phases_all_freqs = 0;
        for freq_k = 1:t.tag_num_freqs,
          phases_all_freqs = phases_all_freqs*360 + ...
            t.tag_phases_vec((slice_j-1)*t.tag_num_freqs+freq_k);
        end
        for freq_k = 1:t.tag_num_freqs,
          obscount = obscount + 1;
          phase_idx = phase_idx + 1;
          obs(obscount, :) = [ ...
            seq_vec, ...
            ftag2_vec, ...
            slice_j, ...
            freq_k, ...
            phases_all_freqs, ...
            t.tag_phases_vec(phase_idx), ...
            t.ftag2_phases_vec(phase_idx), ...
            angularDiff(t.tag_phases_vec(phase_idx), t.ftag2_phases_vec(phase_idx)), ...
            t.ftag2_mags_vec(phase_idx), ...
            ];
        end
      end
    end
    
    seqcount = seqcount + 1;
    seq(seqcount, :) = [seq_vec, ftag2_vec];
  end
end

% Convert into dataset array
dataset.seqds = mat2dataset(seq, 'VarNames', {...
  'id_seq', ...
  'tag_width_m', ...
  'tag_tx_m', ...
  'tag_ty_m', ...
  'tag_tz_m', ...
  'tag_rx_deg', ...
  'tag_ry_deg', ...
  'tag_rz_deg', ...
  'tag_pitch_deg', ...
  'tag_yaw_deg', ...
  'tag_roll_deg', ...
  'tag_oop_deg', ...
  'ftag2_num_tags_detected', ...
  'id_frame', ...
  'ftag2_width_px', ...
  'ftag2_tx_m', ...
  'ftag2_ty_m', ...
  'ftag2_tz_m', ...
  'ftag2_rx_deg', ...
  'ftag2_ry_deg', ...
  'ftag2_rz_deg', ...
  'ftag2_pitch_deg', ...
  'ftag2_yaw_deg', ...
  'ftag2_roll_deg', ...
  'ftag2_oop_deg', ...
  'ftag2_tag_img_rot', ...
  'diff_tx_m', ...
  'diff_ty_m', ...
  'diff_tz_m', ...
  'diff_txy_m', ...
  'diff_txyz_m', ...
  'diff_rx_deg', ...
  'diff_ry_deg', ...
  'diff_rz_deg', ...
  'diff_pitch_deg', ...
  'diff_yaw_deg', ...
  'diff_roll_deg', ...
  'diff_oop_deg', ...
  'diff_rxy_deg', ...
  'quad_corner1x_px', ...
  'quad_corner1y_px', ...
  'quad_corner2x_px', ...
  'quad_corner2y_px', ...
  'quad_corner3x_px', ...
  'quad_corner3y_px', ...
  'quad_corner4x_px', ...
  'quad_corner4y_px', ...
  'quad_diag1_px', ...
  'quad_diag2_px', ...
  'quad_area_px2', ...
  'quad_border_mindist_px', ...
  'diff_payload_str_n', ...
});

dataset.ds = mat2dataset(obs, 'VarNames', {...
  'id_seq', ...
  'tag_width_m', ...
  'tag_tx_m', ...
  'tag_ty_m', ...
  'tag_tz_m', ...
  'tag_rx_deg', ...
  'tag_ry_deg', ...
  'tag_rz_deg', ...
  'tag_pitch_deg', ...
  'tag_yaw_deg', ...
  'tag_roll_deg', ...
  'tag_oop_deg', ...
  'ftag2_num_tags_detected', ...
  'id_frame', ...
  'ftag2_width_px', ...
  'ftag2_tx_m', ...
  'ftag2_ty_m', ...
  'ftag2_tz_m', ...
  'ftag2_rx_deg', ...
  'ftag2_ry_deg', ...
  'ftag2_rz_deg', ...
  'ftag2_pitch_deg', ...
  'ftag2_yaw_deg', ...
  'ftag2_roll_deg', ...
  'ftag2_oop_deg', ...
  'ftag2_tag_img_rot', ...
  'diff_tx_m', ...
  'diff_ty_m', ...
  'diff_tz_m', ...
  'diff_txy_m', ...
  'diff_txyz_m', ...
  'diff_rx_deg', ...
  'diff_ry_deg', ...
  'diff_rz_deg', ...
  'diff_pitch_deg', ...
  'diff_yaw_deg', ...
  'diff_roll_deg', ...
  'diff_oop_deg', ...
  'diff_rxy_deg', ...
  'quad_corner1x_px', ...
  'quad_corner1y_px', ...
  'quad_corner2x_px', ...
  'quad_corner2y_px', ...
  'quad_corner3x_px', ...
  'quad_corner3y_px', ...
  'quad_corner4x_px', ...
  'quad_corner4y_px', ...
  'quad_diag1_px', ...
  'quad_diag2_px', ...
  'quad_area_px2', ...
  'quad_border_mindist_px', ...
  'diff_payload_str_n', ...
  'tag_slice', ...
  'tag_freq', ...
  'tag_slice_wide_phase_id', ...
  'tag_phase_deg', ...
  'ftag2_phase_deg', ...
  'diff_phase_deg', ...
  'ftag2_mag', ...
  });

end
